# 1 软件测试基础

**关键字**

覆盖率（coverage）， 调试（debugging）， 缺陷（defect），错误（ error），
失效（failure）， 质量（quality）， 质量保证（quality assurance），根本原因（
root cause）， 测试分析（test analysis）， 测试依据（test basis），
测试用例（test case）， 测试完成（test completion），测试条件（ test
condition）， 测试控制（test control）， 测试数据（test data）， 测试设计（test
design）， 测试执行（test execution）， 测试执行进度（test execution
schedule）， 测试实现（test implementation）， 测试监视（test monitoring），
测试对象（test object）， 测试目标（test objective）， 测试准则（test oracle），
测试计划（test planning）， 测试规程（test procedure）， 测试套件（test
suite）， 测试（testing）， 测试件（testware）， 可追溯性（traceability），
确认（validation）， 验证（verification）

**软件测试基础的学习目标**

**1.1 什么是测试**

FL-1.1.1 (K1)识别典型的测试目标 

FL-1.1.2 (K2)区分测试和调试

**1.2 为什么需要测试**

FL-1.2.1 (K2)举例说明为什么测试是必须的

FL-1.2.2 (K2)描述测试和质量保证的关系，并举例说明测试如何提高质量

FL-1.2.3 (K2)区分错误、缺陷和失效

FL-1.2.4 (K2)区分缺陷的根本原因和它的影响

**1.3 七个测试原则**

FL-1.3.1 (K2)解释七个测试原则

**1.4 测试过程**

FL-1.4.1 (K2)解释测试过程的上下文的影响

FL-1.4.2 (K2)描述测试过程中的活动和相关任务

FL-1.4.3 (K2)区分支持测试过程的工作产品

FL-1.4.4 (K2)解释维护测试依据和测试工作产品之间的可追溯性的价值

**1.5 测试心理学**

FL-1.5.1 (K1)识别影响测试成功的心理因素

FL-1.5.2 (K2)解释测试活动和开发活动所需要的思维的不同

## *1.1 什么是测试*

从商业应用（例如：银行）到消费类产品（例如：汽车），软件系统已经成为人们生活的一部分。很多人都经历过软件没有按照预期工作的情况。软件没有正常工作会导致各种各样的问题，例如：金钱、时间或者商誉的损失，更有甚者会导致人员的伤亡。软件测试是评估软件并降低软件在运行过程中发生失效风险的一种方法。

对测试的一个常见误解是认为测试只包括测试执行，即执行软件并检查结果。正如1.4节中所描述的，软件测试是由多个不同测试活动组成的过程，测试执行（包括结果检查）只是这些活动中的一个。测试过程还包括很多活动，例如：测试计划、分析、设计和实现，报告测试进度和结果，以及评估测试对象的质量。

如果测试涉及被测试组件或系统的执行，该测试称为动态测试。如果测试不涉及被测试组件或系统的执行，这样的测试称为静态测试。因此，测试也包括评审工作产品，例如：需求、用户故事和源代码等。

对测试的另外一个常见误解是它只关注需求、用户故事或者其它规格说明的验证。虽然测试确实涉及检查系统是否满足特定的需求，但是测试还涉及确认，即检查系统是否满足用户和其它利益相关者在其运行环境下的要求。

不同生命周期中，测试活动的组织和执行是不同的（见2.1节）。

### 1.1.1 典型的测试目标

软件测试在过去几十年里有了长足的发展。整个历史可以追溯到计算机起源的时候。根据David和Bill在1988年的文章的总结，软件测试的历史可以分为以下几个时期：

-   1956年前 --
    以调试为目的：这个时期，测试并没有被单独从开发活动中区分开来，和测试相关的活动更多的以调试的形式出现的；

-   1957年到1978年 --
    以证明为目的：这个时期，测试和调试已经分开了，测试的主要目的是为了证明软件是能够工作的；

-   1979年到1982年 --
    以破坏为目的：这个时期开始的标识是Myer出版的《软件测试艺术》一书，在书中Myer明确提出发现缺陷是软件测试的目的；

-   1983年到1987年 --
    以评估为目的：这个时期，测试用于对被测试的软件或者系统进行评估，进而提供各种有用的信息；

-   1988年以后 --
    以预防为目的：这个时期开始，越来越多的测试活动前移，更多的从需求和设计阶段就开展相关的测试活动。

David Gelperin， Bill Hetzel， THE GROWTH OF SOFTWARE TESTING， 1988

从不区分测试和调试，到通过测试来预防缺陷，软件测试得到了非常大的发展，期间各种测试技术、工具和思想大量涌现。

从测试目标这个角度来说，了解了上面的软件测试的历史后，我们应该可以更好的理解测试目标的多样性。不同的项目中测试的目标可能是不同的。即使同一个项目中，测试也可以有多个目标。针对任何给定项目，其测试目标可能包括：

-   评估工作产品，例如：需求、用户故事、设计和代码

-   验证是否已满足所有描述的需求

-   确认测试对象是否完整，并按照用户和其它利益相关者的预期工作

-   建立对测试对象质量级别的信心

-   预防缺陷

-   发现失效和缺陷

-   为利益相关者提供足够的信息帮助他们做出合适的决定，尤其是考虑测试对象的质量级别

-   降低软件质量低下的风险级别（例如：运行环境中出现了之前未被发现的失效）

-   符合合同、法律或者法规的需求或者标准，和/或验证测试对象符合这些需求或者标准

测试的目标可以有所不同，这取决于被测组件或系统的上下文、测试级别和软件开发生命周期模型。例如：

-   组件测试时，一个目标可能是发现尽可能多的失效，以便及早识别和修复潜在的缺陷。另一个目标可能是增加组件测试的代码覆盖率。

-   验收测试时，一个目标可能是确认系统按照预期工作并满足要求。测试的另一个目标可能是向利益相关者提供在指定时间发布系统的风险信息。

### 1.1.2 测试和调试

软件调试（debug）是软件实现过程的一部分，与软件编码过程同步进行。软件调试的目的是保证程序正常运行，排除编码的语法、语义和逻辑错误，保证程序稳定运行，并符合设计要求。软件调试的特点包括：

-   软件调试主要是程序员自己参与，对程序（设计、编码）进行修改、排除错误，主要是在开发阶段；

-   具体的调试任务没有办法提前计划，具有随机性，不受时间约束，是开发人员为了程序可运行而进行的，其进度不可度量；

-   调试的对像只能是代码；

-   调试从未知的条件开始，其结局不可预知；

-   调试时，开发人员能利用的工具主要是调试器；

-   调试必须由了解详细设计的开发人员完成。 

软件测试（test）是检验程序的手段，在软件编码基本完成后进行，分模块测试和整体测试。目的是保证程序的功能符合要求，排除设计错误，对程序进行系统全面的检查，保证程序整体的功能、性能和可靠性等。相对于软件调试，软件测试的特点包括：

-   软件测试是软件测试人员和程序员都参与的一项工作，是贯穿整个生命周期的；

-   软件测试可以计划，可以预先制定测试用例和过程，工作进度可以度量；

-   测试的对像可以是文档和代码；

-   软件测试从一个已知的条件开始，有预知的结局；

-   大量的测试的执行和设计可以由工具支持；

-   测试经常是由独立的测试组完成。

## *1.2 为什么需要测试*

### **1.2.1 测试对成功的贡献**

由软件缺陷所导致的事故在人们的生活中并不少见，网站承受不了大量用户访问而奔溃；ATM机由于提款机内部软件缺陷导致用户提款操作失败，但是帐户上的余额却被意外的扣除；还有大家非常熟悉的手机，由于手机软件缺陷导致手机经常死机或者通话中断的现象比比皆是，不仅影响了用户的正常使用，而且一定程度上降低了商家的信誉度。可见，日常生活中软件缺陷无处不在，由它导致的不良后果也在时刻影响着人们的方方面面，因此，软件测试的重要性不容忽视。

2013年美国联邦政府的在线保险网站已经成为IT领域出错的一个典型事件。这次事件已经不单单是一次简单的停机事件。该故障导致了一系列的硬中断和软中断，最终使该网站的功能几乎全部丧失。联邦政府曾尝试增加更多硬件设施来做弥补，但该网站在十二月初直到奥巴马管理的“IT团队”正确定位软件和解决数据瓶颈时才恢复其功能。之后，又通过正式成立医疗改革法案以及政治审查，该网站的性能才趋于完备。恢复之后的网站在一些会导致系统崩溃的关键点上加强了防备。

http://server.zdnet.com.cn/server/2014/0103/3007608.shtml，2013年度全球市场十大服务器宕机事件

在IT的整个历史中，软件和系统投入运行后，由于存在缺陷，随后导致故障或无法满足利害关系方的需要，这种现象很常见。但是，使用适当的测试技术可以减少这种有问题交付的频率，只要这些技术是在适当的测试技能、适当的测试级别和软件开发生命周期的适当时间点上应用的。例如：

-   测试人员参与需求评审或用户故事优化能够发现这些工作产品中的缺陷。识别并移除需求中的缺陷能够降低开发错误或者功能出问题的风险。

-   在系统设计时，测试人员与系统设计人员紧密合作，可以提高双方对设计和如何测试的理解。这种理解的增加可以减少基本设计出现缺陷的风险，并能在早期识别相关的测试。

-   在开发代码时，测试人员与开发人员紧密合作，可以提高各方对代码的理解和掌握如何测试代码。这种理解的增加可以降低代码和测试中出现缺陷的风险。

-   测试人员在发布前验证和确认软件能够发现可能被遗漏的缺陷，并为解决导致失效的缺陷相关的过程（例如：调试）提供支持。这样可以提高软件满足利益相关者的要求和满足需求的可能性。

除了上述例子，满足定义的测试目标（见1.1.1节）有助于整个软件开发和维护的成功。

### 1.2.2 质量保证和测试

在招聘网站上，我们经常看到招聘测试工程师和质量保证工程师的职位描述几乎是一样的。很多公司把测试人员和质量保证人员的职责等同起来。这种称呼其实是不准确的。软件测试人员的一项重要任务是提高软件质量，但不等于说软件测试人员就是软件质量保证人员，因为测试只是软件质量保证工作中的一个环节。软件质量保证和软件测试是软件质量工程的两个不同层面的工作。

软件质量保证的重要工作是通过预防、检查与改进来保证软件质量。在软件质量保证的活动中也有一些测试活动，但所关注的是软件质量的检查与测量。软件质量保证的工作是在软件生命周期中管理以及检查软件是否满足规定的质量和用户的需求，因此主要着眼于软件开发活动中的过程、步骤和产物，而不是对软件进行剖析找出问题或评估。软件质量保证的另一个工作是帮助建立软件质量标准、评审的过程和方法以及测试过程的建立。同时跟踪、审计和评审软件开发和测试过程中发现的问题，从而帮助改进开发过程和测试过程。质量保证的主要工作内容包括：

-   建立软件质量保证活动的实体

-   制订软件质量保证计划

-   坚持各阶段的评审和审计，跟踪其结果，并进行合适的处理

-   监控软件产品的质量

-   收集和分析软件质量保证活动的数据

-   度量软件质量保证活动

软件测试关心的不是过程的活动，而是对过程的产物以及开发出的软件产品进行剖析。测试人员对软件产品进行动态测试，以及对过程中的工作产品，比如需求文档、设计文档和源代码进行静态测试，以找出问题，从而评估软件产品质量。测试人员必须假设软件存在潜在的问题，测试中所作的操作是为了找出更多的问题，而不仅仅是为了验证每个功能或者需求条目是否正确。对测试中发现的问题的分析、跟踪与回归测试也是软件测试中的重要工作。软件测试的主要阶段包括：

-   测试计划

-   测试监控

-   测试分析

-   测试设计

-   测试实现

-   测试执行

-   测试结束

通过测试可以发现软件系统在各方面存在的缺陷，包括功能和非功能需求方面的缺陷。当测试发现很少或者没有发现缺陷的时候，就会对软件的质量充满信心。一个设计正确、合理的测试完成并顺利通过，可以降低整个系统存在问题的风险。而对测试过程中发现的缺陷进行修正，则可使软件系统的质量提高。所以说，软件测试是提高软件质量的一个重要手段。

### 1.2.3 错误、缺陷和失效

这一节主要是描述ISTQB中涉及到的三个术语，错误、缺陷和失效之间的区别。一说起术语，大家可能就头疼。感觉这个是偏理论，没什么用处。刚开始的时候，很多人都有这样的想法。但是学习多了后发现，在有些时候术语还是有用的。有了术语和它的定义，能够保证大家在聊一些话题的时候，避免了“鸡同鸭讲”的情况。例如：“性能测试”，大家可以互相问问看。不同的人理解可能都是不同的。回到这节的主题，我们来看一下这三个术语之间到底有什么区别。

每个人都会犯错误（Error、Mistake），而错误会导致在软件代码或者其他一些相关工作产品中引入缺陷（defect、fault或bug）。导致在一个工作产品中引入缺陷的错误可以触发另外一个导致相关工作产品中引入缺陷的错误。例如：需求引发的错误会导致需求缺陷，进而引起编程错误导致代码中存在缺陷。

代码中的缺陷如果被执行，可能会导致一个失效，但并不是所有情况都是这样的。例如：有些缺陷需要特定输入或前提条件才会触发失效，因此极少甚至从来没有发生。

很多原因都会导致错误的发生，例如：

-   时间压力

-   人类的易错性

-   没有经验或者技能不足的项目参与者

-   项目参与者之间沟通不畅，包括需求和设计的错误沟通

-   代码、设计、架构、待解决的问题和/或使用的技术的的复杂性

-   错误理解系统间和系统内的接口，尤其是在系统内和系统间交互频繁时

-   新的、不熟悉的技术

除了代码中的缺陷会导致失效外，环境因素也会导致失效。例如：辐射、电磁场和污染会导致固件中的缺陷，或者通过改变硬件条件影响软件的执行。

并非所有非预期的测试结果都是失效。由于测试执行的方式错误，或者由于测试数据、测试环境或其他测试件的缺陷，或由于其他原因，也可能会发生误报（假阳性False
Positives）。反之亦然，也可能会导致漏测（假阴性False
Negatives）。漏测是测试没有发现它应该发现的缺陷；而误报是报告的缺陷实际上不是真正的缺陷。

### 1.2.4 缺陷、根本原因和影响

缺陷的根本原因是导致缺陷的那些最早出现的行动或者条件。通过分析缺陷识别他们的根本原因，可以减少将来出现类似缺陷的可能性。通过关注最重要的根本原因，根本原因分析可以触发流程改进进而很好的预防未来的缺陷的引入。

对缺陷根本原因的分析是一个刨根问底的过程。很多时候，我们对缺陷的分析可能还是停留在表象，没有真正获得最早的引起缺陷的问题。举个生活中的例子，当某个小学生数学考试分数不高，在进行考后分析的时候，我们经常会发现，很多计算题不是不会做，而是因为”粗心“。看起来”粗心“是一个非常明显的造成数学计算错误的原因。但是”粗心“真的是根本原因吗？为什么有的同学”粗心“多，有的”粗心“少？简单的十以内的加减法为什么不粗心，而100以内的加减法就粗心多呢？再深究的话，你可能会发现，可能是小朋友题目做的少了，需要更多的练习，准确率自然就可以提升了；当然也可能是，小朋友做的题目超过了他这个年龄能够接受的难度了。

在我们平时的测试中，针对发现的缺陷，也同样有一个刨根问底的过程。例如：假设由于一行错误代码导致错误的支付了利息，从而引起客户的抱怨。由于产品负责人错误的理解利息的计算方法，造成了相关的用户故事描述不清，而这段代码就是针对该用户故事的。如果在利息计算中存在大量的缺陷，而这些缺陷的根本原因都是由于类似的误解，那么产品负责人应该通过参加利息计算相关的培训，从而减少将来产生类似缺陷。

这个例子中，客户抱怨就是影响。错误的利息支付是失效。代码中不合适的计算是缺陷，该缺陷来源于模糊不清的用户故事这个初始的缺陷。这个初始缺陷的根本原因是产品负责人缺乏相关知识，从而导致他在编写用户故事时犯了错误。根本原因分析的流程在ISTQB-ETM专家级测试管理大纲和ISTQB-EITP专家级改进测试流程大纲进行了讨论。

## *1.3 七个测试原则*

在过去的50年里，有很多关于测试原则的建议，它们为所有的测试提供了通用的指导。

**1. 测试显示缺陷的存在，而不是显示不存在缺陷**

当刚开始看到这个原则的时候，第一反应可能是：这个原则不是废话嘛！测试肯定可以显示缺陷的存在啊！测试了，发现缺陷了，自然就显示了缺陷的存在；同时测试当然不可能说明系统不存在缺陷了，缺陷是没办法全部消灭的。但是如果看一下这个原则的由来，可能有会有不同的想法。

这个原则最早是由Edsger W. Dijkstra在1969年提出来的（https://en.wikiquote.org/wiki/Edsger_W._Dijkstra）。

他还获得过图灵奖。由于离现在的时间太久，我们可能很难理解当时对于测试的看法。但要是告诉你，提出发现缺陷是软件测试的一个主要目的，是在1979年的话，你可能会有不同的感受。这个原则提出的时候，整个测试领域都还没有把发现缺陷作为主要目的之一，在20世纪60年代，整个软件工程对于测试的理解还远远没有现在这么透彻的情况下，能提出这样的原则是非常有前瞻性的。

测试能够显示缺陷的存在，但是不能证明不存在缺陷。测试降低了软件中遗留的缺陷未被发现的可能性，但是即使没有发现缺陷，也不能证明软件是完全正确的。

Dijkstra (1969) J.N. Buxton and B. Randell， eds， Software Engineering
Techniques， April 1970， p. 16. Report on a conference sponsored by the NATO
Science Committee， Rome， Italy， 27–31 October 1969.

**2. 穷尽测试是不可能的**

现在的各种软件系统越来越庞大，功能也越来越复杂，我们非常容易就可以理解到穷尽测试是不可能的。

就以最简单的一个用户名和密码登录为例吧。很多网站都需要通过用户名和密码登录，如果我们要穷尽测试需要多少个测试用例？

-   用户名和密码可以是英文字母、数字、各种符号，英文字母还可以分大小写，还可能支持中文

-   需要测试字母、数字、符号和中文的各种组合

-   需要针对不同的长度的用户名和密码进行组合

-   还要测试各种异常情况，就算密码只支持8位，那么9位、10位，甚至65535位，有机会的话这些异常情况是否也应该测试呢

这么一算，要想穷尽测试，这里要测试的测试用例用”亿“做单位都觉得太渺小了。现实生活中比用户名和密码还简单的测试恐怕不多了。

这个原则非常重要，它不仅告诉我们可能的测试很多，我们没有办法穷尽它，还告诉我们根据这个原则测试团队应该不断的对测试活动进行改进，以利用现有资源尽可能的进行最有价值的测试。很多软件测试的思想和技术都是由这个原则引起的：

-   风险分析：相对于测试所有的可能，通过风险分析，让测试关注在高风险的地方，从而达到投资回报最优

-   各种测试技术：对输入数据进行等价类的划分，区分白盒中的不同的覆盖率（语句覆盖、分支覆盖等）

-   各种开发实践：使用更好的编程规范，例如：尽量减少用户输入不可控的字符，而是用选择框来取代，典型的像输入日期，相对于让用户可以输入的文字框，下拉列表显然更好的避免了各种错误格式的输入

**3. 尽早测试以节约时间和成本**

为尽早发现缺陷，应该尽可能早的在软件开发生命周期的前期开始静态和动态测试。尽早测试有时称为前移。在软件生命周期的早期进行测试有助于减少或者消除高成本的变更（见3.1节）。

很多数据都说明在早期发现并修复缺陷的成本较低。图1.3-1就是其中之一。我们不用纠结于产品发布后发现修复缺陷的成本是否正好是需求阶段发现和修复缺陷的一百倍。但是凭借我们的常识就可以认识到尽早测试对于缺陷发现和修复成本的降低是非常有意义的。假如在需求评审时发现一个缺陷，可能只需要对文字进行更详细的补充说明就可以了，甚至一个人一小时的工作量都不要；但是如果需求阶段的缺陷，遗留到客户现场，可能造成用户的损失、客户支持费用、开发的返工等，恐怕都不是以人天为单位来计算了。

![图片](media/e829ac478388715771a9e4ee03463795.png)

图1.3-1 不同阶段修复缺陷的相对成本

Rosenberg， L.， Hyatt，L.， Hammer， T.， Huffman， L. and Wilson， W. (1998)
Testing Metrics for Requirement Quality， presented at the Eleventh
International Software Quality Week， San Francisco， CA.

尽早测试的另外一个原因是，很多缺陷其实都是来自于需求，可能是需求不完整、遗漏等。根据图1.3-2所示的统计数据，有超过一半的缺陷其实都是来源于需求，真正在代码阶段引入的缺陷只有7%。所以测试必须尽早开展，从需求阶段就应该开始静态测试。

![图片](media/db882a6529f4b548728b9dfc4a908be5.png)

图1.3-2 缺陷的来源

Ramachandran， M. (1996) Requirements-Driven Software Test: Process-Oriented
Approach， ACM SIGSOFT Software Engineering Notes， Vol. 21， Issue 4， pp. 66 –
70.

**4. 缺陷集群效应**

二八定律又名80/20定律、帕累托法则（Pareto‘s
principle）也叫巴莱特定律、朱伦法则（Juran's Principle）、关键少数法则（Vital
FeRule）、不重要多数法则（Trivial Many
Rule）最省力的法则、不平衡原则等，被广泛应用于社会学及企业管理学等。是19世纪末20世纪初意大利经济学家帕累托发现的。他认为，在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%尽管是多数，却是次要的，因此又称二八定律。([https://baike.baidu.com/item/二八定律](https://baike.baidu.com/item/%E4%BA%8C%E5%85%AB%E5%AE%9A%E5%BE%8B))

在测试中也存在这样的二八定律。即80%的缺陷集中在20%的模块中，这就是缺陷集群效应。这里的80%和20%的概念没有那么绝对。但是这种集群效应确实是存在的。我们知道了缺陷的集群效应，可以：

-   事前预测，尽量预防：在产品测试之前，可以根据对开发人员、过程、业务复杂度等方面进行分析，对可能存在缺陷集群的模块进行预测，一方面可以提前和开发人员一起，争取尽早发现缺陷，一方面也可以提前针对可能存在缺陷集群的模块安排更多的测试；

-   事中分析，及时调整：事前的预测可能存在一定的偏差，在测试进行过程中，要不断的对每个模块发现的缺陷进行分析，如果发现了新的缺陷集群，要及时调整测试资源，重点关注这些存在缺陷集群的模块；

-   事后分析，下次改进：整个产品测试完成后，对所有测试过程中发现的缺陷进行分析，对存在缺陷集群的模块，要找到造成缺陷集群的根本原因，从而避免以后的产品出现同样的问题。

**5. 杀虫剂悖论**

杀虫剂悖论是Boris Beizer在他1990年出版的《Software Testing
Techniques》一书中最先提出来的。当农民发现农作物有病虫害的时候，就需要喷洒杀虫剂，以消除病虫害。通常可以杀死绝大部分的害虫，但是非常不幸的是，总会有少量的虫子活下来。存活下来的虫子对该杀虫剂就产生了抗药性，如果来年农民还是用同样的杀虫剂的话，那么对害虫的杀伤力将会大大降低。农民伯伯需要不断地使用新的杀虫剂来对付具有抗药性的害虫，否则农作物就会被害虫吃掉。

杀虫剂悖论对应到软件测试也是一样的。害虫就是测试团队要找到并消灭的缺陷。但是如果测试团队一直使用相同的测试用例，那么显然随着测试用例反复的执行，这些测试用例发现缺陷的效果就会越来越差。当然不仅仅是测试用例存在这样的问题，测试方法和策略也存在同样的问题。随着整个开发团队的能力的不断改进，被测试对象中存在的缺陷也会不断变化，甚至越来越不容易发现。如果反复执行同样的测试，最终这些测试将无法发现任何新的缺陷。为了检测新的缺陷，需要更新测试和测试数据，以及编写新的测试用例。

上面提到的是测试用例，同样的，相同的测试人员测试同一个模块（功能），因长时间测试，形成了思维定式，因此也容易产生懈怠，忽视一些缺陷的存在，也容易导致杀虫剂悖论。解决办法就是采用交叉测试，不同的测试人员，有不同的测试思路和技巧，容易发现被忽视的缺陷。

**6. 测试依赖于上下文**

有个专门的网站是介绍上下文驱动的测试（<http://context-driven-testing.com/>）。下面是其中提到的上下文驱动测试的七个原则：

1.  任何实践的价值依赖于它的上下文。The value of any practice depends on its
    context.

2.  上下文中存在好的实践，但是不存在最佳实践。There are good practices in
    context， but there are no best practices.

3.  一起工作的人是任何项目上下文中最重要的环节。People， working together， are
    the most important part of any project’s context.

4.  随着时间的推移，项目往往以不可预测的方式进行。Projects unfold over time in
    ways that are often not predictable.

5.  产品是一种解决方案。如果对应的问题没有解决，那么这个产品也就没有起作用。The
    product is a solution. If the problem isn’t solved， the product doesn’t  work.

6.  好的软件测试是一个对智力不断挑战的过程。Good software testing is a
    challenging intellectual process.

7.  只有在整个项目中综合应用判断和技能，我们才能够在正确的时间做正确的事情以有效的测试我们的产品。Only
    through judgment and skill， exercised cooperatively throughout the entire
    project， are we able to do the right things at the right times to
    effectively test our products.

不同上下文需要进行不同的测试。例如：

-   安全关键的工业控制软件的测试和电子商务移动APP的测试：这两个测试的上下文不同，导致他们对测试技术的选择，测试成本的考量等都会不同。工业控制软件需要选择更严格的测试技术，更好的覆盖，而移动App可能对尽快上市有更高的要求；

-   敏捷项目中的测试和顺序生命周期项目中的测试：顺序模型中的测试虽然有不同的级别，但是每个级别通常只运行一次，而敏捷项目中每个级别的测试需要多次运行。其他更多的区别，参见2.1节。

**7. 没有错误的谬论（Absence-of-errors is a fallacy ）**

有些组织期望测试人员能够运行所有可能的测试并发现所有可能的缺陷，但是原则1和原则2告诉我们这是不可能的。此外，期望仅仅通过发现并修复大量的缺陷来保证系统的成功是不现实的。例如：完整测试所有描述的需求并修复所有发现的缺陷，仍然会制造出难以使用的系统，它无法满足用户的需要和期望，或比其他竞争类产品更差。

以当年的手机一哥诺基亚为例，曾经如日中天，在功能机的世界里面无人能敌。但是当智能机出现后，很快诺基亚就迎来来灾难性的销量下滑。这种情况是因为诺基亚的测试人员不努力造成的吗？显然不是。网上有很多段子都是用来“调侃”诺基亚的手机质量很高的，怎么用都不坏，甚至可以当砖头用。但是就是这样的质量，在新的时代到来后，没有及时把握用户需求的变化，没有及时感知时代的变迁，结果在智能手机普及的过程中一败涂地。

为了避免这种情况的发生，一方面测试团队需要从客户的角度来考虑产品，要尽可能的保证开发的产品是满足用户需求的；另外一方面，在整个产品开发过程中，要尽早并不断的收集客户反馈，避免只到整个产品都完成后才和最终用户沟通的情况。敏捷开发在很大程度上就可以达到这个目的。

## *1.4 测试过程*

为实现既定的测试目标，一些通用的测试活动集合就是测试过程。

### 1.4.1 基于上下文的测试过程

影响组织测试过程的因素包括但不限于：

-   软件开发生命周期和使用的项目方法

-   考虑的测试级别和测试类型

-   产品和项目风险

-   业务领域

-   运作时的限制，包括但不限于：

    -   预算和资源

    -   时间

    -   复杂度

    -   合同和法规

    -   要求

-   组织的方针和实践

-   要求的内部和外部标准测试过程

-   测试活动和任务

-   测试工作产品

-   测试依据和测试工作产品之间的可追踪性

针对测试依据（包括所有测试级别或类型）定义良好的度量覆盖率标准是非常有意义的。覆盖率标准能够作为关键绩效指标（KPIs）有效的驱动实现软件测试目标的活动。例如：针对移动应用，测试依据包括了需求列表和支持的移动设备列表。每个需求作为测试依据的一个元素，每个支持的设备也是测试依据的一个元素。覆盖率标准可以要求测试依据的每个元素（及元素的笛卡尔乘积）至少有一个测试用例。一旦执行之后，这些测试结果可以告诉利益相关者具体的需求是否满足，以及在支持的设备上是否发现了失效。

### 1.4.2 测试活动和任务

测试过程包括以下主要的活动组：

-   测试计划

-   测试监控

-   测试分析

-   测试设计

-   测试实现

-   测试执行

-   测试结束

每组活动都由一系列的活动组成，每个活动组中的活动可以包括多个独立的任务，这些任务在不同的项目或者发布中各有不同。此外，尽管很多时候这些活动组从逻辑上看是顺序的，但是它们也常常是迭代实现的。例如：敏捷开发涉及软件设计、构建和测试的小迭代，这些小迭代是基于持续的计划活动基础上持续发生的。因此，在这种开发方式中，测试活动也是迭代持续发生的。即使在顺序开发中，逻辑上顺序的活动也会有重叠、合并、并行或者忽略的情况，因此，通常需要在系统和项目的上下文中对这些主要活动进行裁剪。

**1. 测试计划**

测试计划涉及定义测试目标和在上下文约束下符合测试目标的方法（例如：指定合适的测试技术和任务，制订满足最后期限的测试进度）。测试计划可以根据监控活动的反馈进行更新。

**2.测试监控**

测试监视包括使用测试计划中定义的监控指标持续的将实际进度和计划进度做比较。测试监控涉及采取必要的行动以满足测试计划的目标（随着时间的推移可能会更新）。出口准则的评估可以为测试监控提供支持，出口准则评估在有些生命周期中被称为“完成的定义”。

例如，作为某测试级别的一部分，测试执行的出口准则评估包括：

-   根据指定的覆盖率标准检查测试结果和日志

-   根据测试结果和日志评估组件或系统的质量级别

-   决定是否需要更多的测试（例如：如果原本要求达到一定产品风险覆盖率的测试无法满足覆盖率要求，则需要编写和执行额外的测试）

在测试进度报告中向利益相关者通报测试进度，包括与计划的偏差，以及支持作出停止测试决定所需的信息。

**3.测试分析**

测试分析通过分析测试依据识别可测试的特性并定义相关的测试条件，即测试分析根据可度量的覆盖率标准确定“测试什么”。

测试分析包括以下主要活动：

-   根据所考虑的测试级别分析测试依据，例如：

    -   合同附件/技术附件，例如功能需求、非功能需求；验收测试需要以此为分析依据。

    -   需求规格说明，例如：业务需求、功能需求、系统需求、用户故事、史诗故事、用例，以及类似的指定想要的功能或者非功能组件或系统行为的工作产品；任何测试级别都需要分析需求规格说明，特别是系统测试。

    -   设计和实现信息，例如：系统或软件架构图或文档、设计规格说明、调用流程、建模图（例如：UML或实体关系图）、接口规格说明，以及类似的指定组件或系统结构的工作产品；单元测试、集成测试需要更多的关注设计和实现信息。

    -   组件或系统自身的实现，包括：代码、数据库元数据和查询，以及接口；单元测试和集成测试要更多关注组件的实现。

-   风险分析报告，其中会考虑组件或系统的功能、非功能和结构等方面

-   评估测试依据和测试条目识别各种类型的缺陷，例如：

    -   歧义

    -   遗漏

    -   不一致

    -   不准确

    -   矛盾

    -   多余的语句

-   识别要测试的特性和特性集

-   基于测试依据的分析定义每个特性的测试条件，并进行优先级排序，同时考虑功能、非功能和结构化的特征、其它的商业和技术因素以及风险的级别

-   获得测试依据中每个元素和相关测试条件之间的双向可追溯性

测试分析过程中使用黑盒、白盒和基于经验的测试技术，有助于减少遗漏重要测试条件的可能性，同时也有助于定义更加准确的测试条件。

在有些情况下，测试分析生成的测试条件可以用作测试章程中的测试目标。测试章程是有些基于经验的测试中典型的工作产品。当这些测试目标可以追溯到测试依据时，就可以度量基于经验的测试能达到的覆盖率。

测试分析过程中识别缺陷是一个重要的潜在收益，尤其是在没有使用其它评审过程和/或测试过程和评审过程紧密联系时。测试分析活动不仅验证需求是否一致、表达是否正确和完整，同时可以确认需求是否正确的反映客户、用户和其它利益相关者的需要。例如：像行为驱动开发（BDD）和验收测试驱动开发（ATDD）这样的技术，它们在编码前根据用户故事和验收准则生成测试条件和测试用例，同时也验证、确认和检测用户故事和验收准则中的缺陷（见ISTQB初级敏捷测试大纲）。

**4.测试设计**

测试设计过程中逐步将测试条件生成概要测试用例、概要测试用例集合和其它测试件。因此，测试分析回答“测试什么”的问题，而测试设计回答“如何测试”的问题。

测试设计包括如下主要活动：

-   设计测试用例和测试用例集并划分优先级

-   识别所需的测试数据以支持测试条件和测试用例

-   设计测试环境并识别任何需要的架构和工具

-   获得测试依据、测试条件、测试用例和测试规程之间的双向可追溯性

测试设计过程将测试条件逐步生成测试用例和测试用例集时，通常会使用各种测试技术。

与测试分析一样，测试设计也可能识别测试依据中类似的缺陷类型。同样，测试设计过程中识别缺陷也是一个重要的潜在收益。

**5.测试实现**

测试实现过程将为测试执行创建和/或完成所需的测试件，包括测试规程中测试用例的顺序。因此，测试设计回答“如何测试”的问题，而测试实现回答“运行测试需要的所有东西现在都有了吗？”的问题。

测试实现包括以下主要活动：

-   开发测试规程并划分优先级，创建自动化测试脚本

-   根据测试规程和自动化的测试脚本创建测试套件

-   在测试执行进度表中安排测试套件以保证高效的测试执行

-   构建测试环境（包括测试用具、虚拟化服务、模拟器和其它基础设施），并验证所需的东西都已正确搭建

-   准备测试数据，并确保它正确的加载到测试环境中

-   验证和更新测试依据、测试条件、测试用例、测试规程和测试套件之间的双向可追溯性。

测试设计和实现任务经常集成在一起。

在探索性测试和其它基于经验的测试中，测试设计和实现可能会发生在测试执行中，并记录为测试执行的一部分。探索性测试可以基于测试章程（测试分析输出的一部分），同时探索性的测试在它们设计和实现后立刻执行。

**6.测试执行**

测试执行时，测试套件按照测试执行进度表的安排运行。

测试执行包括以下主要活动：

-   记录测试条目或测试对象、测试工具和测试件的标识和版本

-   通过手工或者测试执行工具执行测试

-   比较实际结果和期望结果

-   分析异常以找到可能的原因（例如：由于代码中的缺陷导致的失效，但也可能是误报）

-   根据观察到的失效报告缺陷

-   记录测试执行的输出（例如：通过、失败、被阻塞）

-   作为针对异常采取的行动或者计划中测试的一部分，重复相关测试活动（例如：执行改正后的测试、确认测试和/或回归测试）

-   验证和更新测试依据、测试条件、测试用例、测试规程和测试结果之间的双向可追溯性。

**7.测试结束**

测试结束活动从已完成的测试活动中收集数据，从而对各种经验、测试件和其它相关信息进行固化。测试结束活动发生在项目里程碑点，例如：软件系统发布时、测试项目完成（或取消）时、敏捷项目迭代完成时（例如：作为回顾会议的一部分）、测试级别完成时，或维护版本完成时。

测试结束包括以下主要活动：

-   检查所有的缺陷报告是否已关闭，为测试执行结束时未解决的所有缺陷创建变更请求或者产品代办列表

-   创建用于和利益相关者沟通的测试总结报告

-   最终确定并归档测试环境、测试数据、测试基础设施和其它测试件，以便将来使用

-   将测试件移交给维护团队、其它项目团队，和/或其它能够从中受益的利益相关者

-   从完成的测试活动中分析经验教训，并确定在将来的迭代、发布和项目中的变更

-   利用收集的信息改进测试过程的成熟度

### 1.4.3 测试工作产品

创建的测试工作产品属于测试过程的一部分。就像组织实施测试过程的方式存在显著差异一样，测试过程中创建的工作产品、工作产品组织和管理的方式，以及工作产品的名称也是千差万别的。本大纲主要遵循上面提到的测试过程以及在本大纲和ISTQB术语表中描述的工作产品。ISO标准（ISO/IEC/IEEE
29119-3）可以作为测试工作产品的指南。

**1.测试计划工作产品**

测试计划工作产品通常包括一个或多个测试计划。测试计划包括测试依据的信息，而其他测试工作产品通过可追溯性信息与之关联，以及在测试监控时用到的出口准则（或者完成的定义）。

**2.测试监控工作产品**

测试监控工作产品通常包括各种类型的测试报告，包括测试进度报告（持续或者定期生成）和测试总结报告（在各种完成的里程碑点时生成）。所有测试报告应提供与受众相关的截至报告日期的测试进度细节，包括获得测试执行结果后的总结。

测试监控工作产品还应考虑项目管理方面的问题，如任务完成、资源分配和使用以及工作量。

本书第5.3节进一步解释了测试监控以及在这些活动期间生成的工作产品。

**3.测试分析工作产品**

测试分析工作产品包括定义并排好优先级的测试条件，理想情况下这些测试条件可以双向追溯到具体测试依据的条目。针对探索性测试，测试分析可能包括创建测试章程。测试分析也可能发现并报告测试依据中存在的缺陷。

**4.测试设计工作产品**

通过测试设计得到测试用例和测试用例组以覆盖测试分析识别的测试条件。设计没有输入数据和预期结果的概要测试用例，通常是一个好的实践。通过使用不同的具体数据，概要测试用例可以在多个测试周期中复用，同时确保测试用例的范围被充分文档化。理想情况下，每个测试用例可以双向追溯到它所覆盖的测试条件。

测试设计的同时还包括设计和/或识别必要的测试数据、设计测试环境的以及确定基础设施和工具，但是文档化这些结果的详细程度差别很大。

测试分析过程中识别的测试条件会在测试设计过程中得到进一步细化。

**5.测试实现工作产品**

测试实现工作产品主要包括：

-   测试规程和测试规程中的执行顺序

-   测试套件

-   测试执行进度计划

理想情况下，一旦测试实现完成，就可以通过测试用例和测试条件，以及测试规程和测试依据中的条目之间的双向可追溯性，展示测试计划中制定的覆盖标准的实现。

在某些情况下，测试实现涉及使用工具创建工作产品或创建工具所使用的工作产品。例如，服务虚拟化和自动化测试脚本。

测试实现也包括测试数据和测试环境的创建和验证。数据和/或环境验证结果文档化的完整性可能有很大差异。

测试数据用于确定测试用例的输入和预期结果的具体的值。具体的值加上其用法可以将概要测试用例转变成可执行的详细测试用例。在测试对象的不同版本执行时，同样的概要测试用例可以使用不同的测试数据。与详细测试数据关联的详细预期结果，可以通过使用测试准则得到。

探索性测试中，尽管探索性测试（以及对测试依据中特定条目的可追溯性）的文档化程度可能会有很大差异，但一些测试设计和实现工作产品仍会在测试执行阶段生成。

测试分析阶段识别的测试条件，可能会在测试实现阶段得到进一步的细化。

**6.测试执行工作产品**

测试执行工作产品主要包括：

-   文档化每个测试用例或测试规程的状态（例如：准备运行、通过、失败、被阻塞、有意跳过等）

-   缺陷报告

-   文档化测试过程中包含的测试条目、测试对象、测试工具和测试件

理想情况下，一旦测试执行完成，就可以通过与相关测试规程的双向可追溯性来确定和报告测试依据中的每个条目状态。例如：我们可以说哪些需求已经通过了所有计划中的测试，哪些需求存在测试失败和/或与之相关的缺陷，以及哪些需求还有计划中的测试等待运行。这些有助于验证否达到了覆盖标准，并能够以利益相关者可以理解的方式汇报测试结果。

**7.测试结束工作产品**

测试结束工作产品包括测试总结报告、后续项目或迭代的改进行动计划（例如：在项目回顾之后）、变更请求或产品待办条目，以及最终确定的测试软件。

1.4.4 测试依据与测试工作产品的可追溯性

如第1.4.3节所述，测试工作产品和它们的名称差别很大。不管如何变化，为了实施有效的测试监控，在整个测试过程中，必须在测试依据的每个元素和与该元素相关的各种测试工作产品之间建立和保持可追溯性。除了测试覆盖率的评估，好的可追溯性还能支持：

-   分析变更影响：例如建立了从需求到测试用例的可追溯性后，一旦需求有变化，就能够知道有哪些测试用例需要更新

-   使测试可审计

-   包含测试依据元素的状态（例如：通过测试的需求、测试失败的需求和延迟测试的需求），有助于提高测试进度报告和测试总结报告的易理解性

-   以利益相关者可以理解的方式关联测试技术

-   根据业务目标，为评估产品质量、过程能力和项目进度提供信息

有些测试管理工具提供了测试工作产品的模板，该模板与本节概述的部分或全部测试工作产品相匹配。有些组织建立自己的管理系统来组织工作产品并提供他们所需要的信息可追溯性。

## *1.5 测试心理学*

在整个软件生命周期中，有很多不同的活动，也涉及到很多流程和方法。虽然我们对各种活动进行了很详细的定义，但是具体的执行过程中仍然避不开人的因素。所以测试人员在具体执行的过程中，需要考虑到人的因素，了解一些心理学的知识，对于测试人员理解并解决工作中碰到的一些困难是非常有帮助的。

### 1.5.1 人类心理学与测试

人类心理学中有个概念叫“确认偏差”（confirmation bias）。它指的是当一个人已经存在某种信仰或者假设，他会主动搜索、解释和回忆那些有利于解释这个信仰或者假设的信息，而忽略那些不利信息。这是一种认知偏差和归纳推理的系统性错误。

（参见https://en.wikipedia.org/wiki/Confirmation_bias）

人类心理学中存在的确认偏差，会使人们难以接受与目前所持信仰相悖的信息。例如：由于开发人员期望他们的代码是正确的，所以他们的确认偏差使得他很难接受代码是不正确的。这样一方面开发人员自己测试自己代码的时候，经常有盲点；另一方面，当测试人员发现缺陷的时候，开发人员的第一反应就是抵触。这里提到开发人员的确认偏差，并不是要批评开发人员。而是希望测试人员能够更好的面对开发人员的一些反应。其实测试人员自己也存在确认偏差，测试人员无论是制定测试计划，还是编写测试用例，或者提交缺陷报告的时候都同样可能出现确认偏差。这是大部分人的一种正常心理状态。想要完全避免是很困难的，我们要做的是更好的应对。

测试人员经常会提交各种缺陷，或者带来很多关于产品质量的坏消息。这些都可能使得测试人员作为坏消息的传递者而受到指责。

为了应对工作中可能出现的各种负面影响，测试人员除了专心做事以外，也要注意“做人”方面的锻炼。测试人员和测试经理需要有良好的人际交往技巧，以便能够有效地沟通缺陷、失效、测试结果、测试进度和风险，并与同事建立积极的关系。良好的沟通方式包括以下例子：

-   以合作而非争斗的方式开始。提醒大家的共同目标是更高质量的系统。

-   强调测试的收益。例如：对作者而言，缺陷信息可以帮助他们改进他们的工作产品和技能。对组织而言，在测试过程中发现并修复的缺陷将节省时间和金钱，降低产品质量的整体风险。

-   以中立、注重事实的方式传达测试结果和其他发现，而不是批评引入缺陷的人。编写客观和基于事实的缺陷报告和评审意见。

-   设法了解对方的感受以及他们可能对信息作出消极反应的原因。

-   确认对方已理解所说的话，反之亦然。

前面讨论了典型的测试目标（见1.1节）。明确定义正确的测试目标集具有重要的心理影响。大多数人倾向于将他们的计划和行为与团队、管理层和其他利益相关者设定的目标协调一致。测试人员以最小的个人偏见坚持这些目标也很重要。

### 1.5.2测试人员和开发人员的思维模式

通常认为软件开发是建设性行为，他们的首要目标是设计和构建；而软件测试则是破坏性行为，是寻找开发人员在设计和构建过程存在的问题。

“开发人员可以测试他们自己开发的程序么？”是一个经常被问到的问题。对这个问题没有一个标准的答案。理想情况当然最好是开发人员自己一个人同时完成开发和测试任务，开发人员首先利用建设性的思维设计并开发一个系统，然后用破坏性的思维来验证和确认这个系统。不论这样的人是否广泛存在，但看前后从建设性思维到破坏性思维的切换，就可以想象要求一个开发人员做到这种程度是非常有挑战的。这要求开发人员能够不断的自我颠覆，在一定程度上可以说这是违背人性的。又有谁愿意去寻找自己辛辛苦苦开发出来的系统的错误呢？他们更多的宁愿证明自己的源代码工作如何出色。

开发人员测试的最大弱点在于每个必须测试自己程序的开发人员往往过于乐观。这样就蕴含一种危险：由于开发人员对开发程序比测试更有兴趣，或者测试进行得非常肤浅而忘记了执行合理的测试用例。

如果开发人员引入了一个基础的设计错误，例如：他们对一个概念的描述有误解，那么他们很有可能无法检测出自己的错误。甚至他们都不会想到合适的测试用例去揭示这样的错误。减少这种“对自己错误视而不见”问题的一种可能方法是结对工作，即由同事来检查自己的程序。

当然从另一方面来说，开发人员对自己的测试对象非常了解是它的一个优势。测试时由于不需要再去了解测试对象，因而节省了时间。管理者必须决定是选择对自己错误视而不见的不利条件，还是选择节省时间这种优势。这种决策必须对测试对象的重要程度和相关的失效风险进行综合考虑。

一个独立的测试团队会提高测试的质量和对测试的理解力。测试人员可以毫无偏见的看待测试对象。因为这不是“他们”的产品，而且对于开发人员的可能的假设和误解对测试人员不再是障碍。为了创建测试用例，测试人员会花费相应的时间成本来了解测试对象，然后测试人员具有比较深厚的测试知识基础，这是开发人员一般不具备或者当需要时不得不临时补充的知识。更多关于测试独立性的内容，参加5.1.1节。

就像1.3节中提到的一个关于测试依赖于上下文的原则一样，很多时候并不是一个非黑即白的问题。开发人员自测有自己的优势，也存在一定的局限。所以最终开发人员和测试人员合作是一个非常好的解决方案。当然测试任务的这个平衡点是偏向开发人员一些还是偏向测试人员多一些，显然要根据各个不同的项目场景来决定。
